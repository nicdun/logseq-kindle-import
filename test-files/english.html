<!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Strict//EN"
"XHTML1-s.dtd" >
<html xmlns="http://www.w3.org/TR/1999/REC-html-in-xml" xml:lang="en" lang="en">
    <head>
    <meta charset="UTF-8">
    <style>
        .bodyContainer {
            font-family: Arial, Helvetica, sans-serif;
            text-align: center;
            padding-left: 32px;
            padding-right: 32px;
        }
        
        .notebookFor {
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            color: rgb(119, 119, 119);
            margin: 24px 0px 0px;
            padding: 0px;
        }
        
        .bookTitle {
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            color: #333333;
            margin-top: 22px;
            padding: 0px;
        }
        
        .authors {
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            color: rgb(119, 119, 119);
            margin-top: 22px;
            margin-bottom: 24px;
            padding: 0px;
        }
    
        .citation {
            font-size: 18px;
            font-weight: 500;
            text-align: center;
            color: #333333;
            margin-top: 22px;
            margin-bottom: 24px;
            padding: 0px;
        }
    
        .sectionHeading {
            font-size: 24px;
            font-weight: 700;
            text-align: left;
            color: #333333;
            margin-top: 24px;
            padding: 0px;
        }
        
        .noteHeading {
            font-size: 18px;
            font-weight: 700;
            text-align: left;
            color: #333333;
            margin-top: 20px;
            padding: 0px;
        }
        
        .noteText {
            font-size: 18px;
            font-weight: 500;
            text-align: left;
            color: #333333;
            margin: 2px 0px 0px;
            padding: 0px;
        }
        
        .highlight_blue {
            color: rgb(178, 205, 251);
        }
        
        .highlight_orange {
            color: #ffd7ae;
        }
        
        .highlight_pink {
            color: rgb(255, 191, 206);
        }
        
        .highlight_yellow {
            color: rgb(247, 206, 0);
        }
        
        .notebookGraphic {
            margin-top: 10px;
            text-align: left;
        }
        
        .notebookGraphic img {
            -o-box-shadow:      0px 0px 5px #888;
            -icab-box-shadow:   0px 0px 5px #888;
            -khtml-box-shadow:  0px 0px 5px #888;
            -moz-box-shadow:    0px 0px 5px #888;
            -webkit-box-shadow: 0px 0px 5px #888;
            box-shadow:         0px 0px 5px #888; 
            max-width: 100%;
            height: auto;
        }
        
        hr {
            border: 0px none;
            height: 1px;
            background: none repeat scroll 0% 0% rgb(221, 221, 221);
        }
        </style>
        <script>
            </script>
    </head>
    <body>
        <div class="bodyContainer">
            <div class="notebookFor">
                Notebook Export
            </div>
            <div class="bookTitle">
                Fundamentals of Software Architecture: An Engineering Approach
            </div>
            <div class="authors">
                Richards, Mark; Ford, Neal
            </div>
            <div class="citation">
                
            </div>
            <hr />
            <div class="sectionHeading">
    Preface: Invalidating Axioms
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Page 4 · Location 52
</div>
<div class="noteText">
    For many years, the tongue-in-cheek definition of software architecture was “the stuff that’s hard to change later.” Later, the microservices architecture style appeared, where change is a first-class design consideration.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Page 5 · Location 61
</div>
<div class="noteText">
    As a software developer, it’s easy to become enamored with a particular technology or approach. But architects must always soberly assess the good, bad, and ugly of every choice, and virtually nothing in the real world offers convenient binary choices
</div><div class="sectionHeading">
    1. Introduction
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Page 11 · Location 163
</div>
<div class="noteText">
    Readers should keep in mind that all architectures are a product of their context.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 12 · Location 170
</div>
<div class="noteText">
    In this definition, software architecture consists of the structure of the system (denoted as the heavy black lines supporting the architecture), combined with architecture characteristics (“-ilities”) the system must support, architecture decisions, and finally design principles.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 12 · Location 175
</div>
<div class="noteText">
    The structure of the system, as illustrated in Figure 1-3, refers to the type of architecture style (or styles) the system is implemented in (such as microservices, layered, or microkernel).
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 12 · Location 177
</div>
<div class="noteText">
    Describing an architecture solely by the structure does not wholly elucidate an architecture.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 12 · Location 178
</div>
<div class="noteText">
    talking about the structure of the system, but not the architecture of the system.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 13 · Location 181
</div>
<div class="noteText">
    
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 13 · Location 182
</div>
<div class="noteText">
    Architecture characteristics are another dimension of defining software architecture (see Figure 1-4). The architecture characteristics define the success criteria of a system, which is generally orthogonal to the functionality of the system. Notice that all of the characteristics listed do not require knowledge of the functionality of the system, yet they are required in order for the system to function properly.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 14 · Location 187
</div>
<div class="noteText">
    
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 14 · Location 189
</div>
<div class="noteText">
    Architecture decisions define the rules for how a system should be constructed.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 14 · Location 192
</div>
<div class="noteText">
    Architecture decisions form the constraints of the system and direct the development teams on what is and what isn’t allowed.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 15 · Location 193
</div>
<div class="noteText">
    
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 15 · Location 199
</div>
<div class="noteText">
    design principle differs from an architecture decision in that a design principle is a guideline rather than a hard-and-fast rule.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 15 · Location 203
</div>
<div class="noteText">
    An architecture decision (rule) could never cover every condition and option for communication between services, so a design principle can be used to provide guidance for the preferred method (in this case, asynchronous messaging) to allow the developer to choose a more appropriate communication protocol (such as REST or gRPC) given a specific circumstance.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Defining Software Architecture > Page 16 · Location 207
</div>
<div class="noteText">
    
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Expectations of an Architect > Page 16 · Location 212
</div>
<div class="noteText">
    There are eight core expectations placed on a software architect, irrespective of any given role, title, or job description: Make architecture decisions Continually analyze the architecture Keep current with latest trends Ensure compliance with decisions Diverse exposure and experience Have business domain knowledge Possess interpersonal skills Understand and navigate politics
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Make Architecture Decisions > Page 17 · Location 218
</div>
<div class="noteText">
    An architect is expected to define the architecture decisions and design principles used to guide technology decisions within the team, the department, or across the enterprise.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Make Architecture Decisions > Page 17 · Location 219
</div>
<div class="noteText">
    Guide is the key operative word in this first expectation. An architect should guide rather than specify technology choices. For example, an architect might make a decision to use React.js for frontend development. In this case, the architect is making a technical decision rather than an architectural decision or design principle that will help the development team make choices. An architect should instead instruct development teams to use a reactive-based framework for frontend web development, hence guiding the development team in making the choice between Angular, Elm, React.js, Vue, or any of the other reactive-based web frameworks.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Continually Analyze the Architecture > Page 17 · Location 230
</div>
<div class="noteText">
    An architect is expected to continually analyze the architecture and current technology environment and then recommend solutions for improvement.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Continually Analyze the Architecture > Page 18 · Location 236
</div>
<div class="noteText">
    Other forgotten aspects of this expectation that architects frequently forget are testing and release environments. Agility for code modification has obvious benefits, but if it takes teams weeks to test changes and months for releases, then architects cannot achieve agility in the overall architecture.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Keep Current with Latest Trends > Page 18 · Location 241
</div>
<div class="noteText">
    An architect is expected to keep current with the latest technology and industry trends.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Ensure Compliance with Decisions > Page 18 · Location 247
</div>
<div class="noteText">
    An architect is expected to ensure compliance with architecture decisions and design principles.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Diverse Exposure and Experience > Page 19 · Location 258
</div>
<div class="noteText">
    An architect is expected to have exposure to multiple and diverse technologies, frameworks, platforms, and environments.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Diverse Exposure and Experience > Page 19 · Location 260
</div>
<div class="noteText">
    Most environments these days are heterogeneous, and at a minimum an architect should know how to interface with multiple systems and services, irrespective of the language, platform, and technology those systems or services are written in.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Have Business Domain Knowledge > Page 20 · Location 268
</div>
<div class="noteText">
    An architect is expected to have a certain level of business domain expertise.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Possess Interpersonal Skills > Page 20 · Location 278
</div>
<div class="noteText">
    An architect is expected to possess exceptional interpersonal skills, including teamwork, facilitation, and leadership.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Possess Interpersonal Skills > Page 20 · Location 283
</div>
<div class="noteText">
    Leadership skills are at least half of what it takes to become an effective software architect, regardless of the role or title the architect has.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Understand and Navigate Politics > Page 21 · Location 290
</div>
<div class="noteText">
    An architect is expected to understand the political climate of the enterprise and be able to navigate the politics.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Understand and Navigate Politics > Page 22 · Location 307
</div>
<div class="noteText">
    Programming aspects such as code structure, class design, design pattern selection, and sometimes even language choice are all part of the art of programming. However, an architect, now able to finally be able to make broad and important decisions, must justify and fight for almost every one of those decisions.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Intersection of Architecture and… > Page 23 · Location 330
</div>
<div class="noteText">
    elastic scale: the ability to spin up more instances of resources, as needed. Cloud providers offer this feature as a commodity, but in the early days of the internet, companies had to manage their own infrastructure,
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Engineering Practices > Page 23 · Location 342
</div>
<div class="noteText">
    By process, we mean how teams are formed and managed, how meetings are conducted, and workflow organization; it refers to the mechanics of how people organize and interact. Software engineering practices, on the other hand, refer to process-agnostic practices that have illustrated, repeatable benefit. For example, continuous integration is a proven engineering practice that doesn’t rely on a particular process.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Engineering Practices > Page 25 · Location 373
</div>
<div class="noteText">
    All architectures become iterative because of unknown unknowns, Agile just recognizes this and does it sooner.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Engineering Practices > Page 25 · Location 374
</div>
<div class="noteText">
    Thus, while process is mostly separate from architecture, an iterative process fits the nature of software architecture better. Teams trying to build a modern system such as microservices using an antiquated process like Waterfall will find a great deal of friction from an antiquated process that ignores the reality of how software comes together.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Engineering Practices > Page 26 · Location 390
</div>
<div class="noteText">
    
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Engineering Practices > Page 26 · Location 392
</div>
<div class="noteText">
    Thus, architects may design a system to meet certain criteria, but that design must survive both implementation (how can architects make sure that their design is implemented correctly) and the inevitable change driven by the software development ecosystem. What we need is an evolutionary architecture.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Engineering Practices > Page 26 · Location 394
</div>
<div class="noteText">
    Building Evolutionary Architectures introduces the concept of using fitness functions to protect (and govern) architectural characteristics as change occurs over time.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Engineering Practices > Page 26 · Location 397
</div>
<div class="noteText">
    When designing such an algorithm for a specific goal, developers must measure the outcome to see if it is closer or further away from an optimal solution; that measure is a fitness function.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Engineering Practices > Page 26 · Location 402
</div>
<div class="noteText">
    For example, an architect may identify page load time as an importance characteristic of the architecture. To allow the system to change without degrading performance, the architecture builds a fitness function as a test that measures page load time for each page and then runs the test as part of the continuous integration for the project. Thus, architects always know the status of critical parts of the architecture because they have a verification mechanism in the form of fitness functions for each part.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Operations/DevOps > Page 27 · Location 423
</div>
<div class="noteText">
    By creating a liaison between architecture and operations, the architects can simplify the design and rely on operations for the things they handle best. Thus, realizing a misappropriation of resources led to accidental complexity, and architects and operations teamed up to create microservices, the details of which we cover in Chapter
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Process > Page 28 · Location 433
</div>
<div class="noteText">
    However, the process by which teams develop software has an impact on many facets of software architecture.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Process > Page 28 · Location 435
</div>
<div class="noteText">
    Architects in Agile projects can assume iterative development and therefore a faster feedback loop for decisions. That in turn allows architects to be more aggressive about experimentation and other knowledge that relies on feedback.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Process > Page 28 · Location 436
</div>
<div class="noteText">
    As the previous quote from Mark observes, all architecture becomes iterative; it’s only a matter of time. Toward that end, we’re going assume a baseline of Agile methodologies throughout and call out exceptions where appropriate.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Process > Page 28 · Location 440
</div>
<div class="noteText">
    For example, a team started with a monolithic architecture because it was easy and fast to bootstrap, but now they need to move it to a more modern architecture. Agile methodologies support these kinds of changes better than planning-heavy processes because of the tight feedback loop
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Data > Page 28 · Location 445
</div>
<div class="noteText">
    A large percentage of serious application development includes external data storage, often in the form of a relational (or, increasingly, NoSQL) database. However, many books about software architecture include only a light treatment of this important aspect of architecture. Code and data have a symbiotic relationship: one isn’t useful without the other.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Laws of Software Architecture > Page 29 · Location 457
</div>
<div class="noteText">
    Everything in software architecture is a trade-off. First Law of Software Architecture
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Laws of Software Architecture > Page 29 · Location 459
</div>
<div class="noteText">
    If an architect thinks they have discovered something that isn’t a trade-off, more likely they just haven’t identified the trade-off yet.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Laws of Software Architecture > Page 29 · Location 464
</div>
<div class="noteText">
    Why is more important than how. Second Law of Software Architecture
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Laws of Software Architecture > Page 29 · Location 467
</div>
<div class="noteText">
    An architect can look at an existing system they have no knowledge of and ascertain how the structure of the architecture works, but will struggle explaining why certain choices were made versus others.
</div><div class="sectionHeading">
    2. Architectural Thinking
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Page 31 · Location 478
</div>
<div class="noteText">
    Architectural thinking is much more than that. It is seeing things with an architectural eye, or an architectural point of view. There are four main aspects of thinking like an architect. First, it’s understanding the difference between architecture and design and knowing how to collaborate with development teams to make architecture work. Second, it’s about having a wide breadth of technical knowledge while still maintaining a certain level of technical depth, allowing the architect to see solutions and possibilities that others do not see. Third, it’s about understanding, analyzing, and reconciling trade-offs between various solutions and technologies. Finally, it’s about understanding the importance of business drivers and how they translate to architectural concerns.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Architecture Versus Design > Page 31 · Location 489
</div>
<div class="noteText">
    traditional responsibilities an architect has, as compared to those of a developer. As shown in the diagram, an architect is responsible for things like analyzing business requirements to extract and define the architectural characteristics (“-ilities”), selecting which architecture patterns and styles would fit the problem domain, and creating components (the building blocks of the system). The artifacts created from these activities are then handed off to the development team, which is responsible for creating class diagrams for each component, creating user interface screens, and developing and testing source code.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Architecture Versus Design > Page 32 · Location 496
</div>
<div class="noteText">
    As a matter of fact, this illustration shows exactly why architecture rarely works.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Architecture Versus Design > Page 32 · Location 500
</div>
<div class="noteText">
    To make architecture work, both the physical and virtual barriers that exist between architects and developers must be broken down, thus forming a strong bidirectional relationship between architects and development teams. The architect and developer must be on the same virtual team to make this work,
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Architecture Versus Design > Page 32 · Location 503
</div>
<div class="noteText">
    Not only does this model facilitate strong bidirectional communication between architecture and development, but it also allows the architect to provide mentoring and coaching to developers on the team.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Architecture Versus Design > Page 33 · Location 505
</div>
<div class="noteText">
    
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Architecture Versus Design > Page 33 · Location 508
</div>
<div class="noteText">
    So where does architecture end and design begin? It doesn’t. They are both part of the circle of life within a software project and must always be kept in synchronization with each other in order to succeed.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 33 · Location 512
</div>
<div class="noteText">
    Unlike a developer, who must have a significant amount of technical depth to perform their job, a software architect must have a significant amount of technical breadth
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 34 · Location 518
</div>
<div class="noteText">
    any individual can partition all their knowledge into three sections: stuff you know, stuff you know you don’t know, and stuff you don’t know you don’t know.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 34 · Location 519
</div>
<div class="noteText">
    Stuff you know includes the technologies, frameworks, languages, and tools a technologist uses on a daily basis to perform their job, such as knowing Java as a Java programmer.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 34 · Location 520
</div>
<div class="noteText">
    Stuff you know you don’t know includes those things a technologist knows a little about or has heard of but has little or no expertise in.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 34 · Location 523
</div>
<div class="noteText">
    Stuff you don’t know you don’t know is the largest part of the knowledge triangle and includes the entire host of technologies, tools, frameworks, and languages that would be the perfect solution to a problem a technologist is trying to solve, but the technologist doesn’t even know those things exist.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 35 · Location 529
</div>
<div class="noteText">
    However, the stuff you know is also the stuff you must maintain—nothing is static in the software world.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 35 · Location 531
</div>
<div class="noteText">
    The things at the top of the pyramid require time investment to maintain expertise. Ultimately, the size of the top of an individual’s pyramid is their technical depth.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 36 · Location 534
</div>
<div class="noteText">
    A large part of the value of an architect is a broad understanding of technology and how to use it to solve particular problems.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 36 · Location 540
</div>
<div class="noteText">
    As an architect, breadth is more important than depth.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 37 · Location 541
</div>
<div class="noteText">
    Thus, for an architect, the wise course of action is to sacrifice some hard-won expertise and use that time to broaden their portfolio, as shown in Figure 2-6. As illustrated in the diagram, some areas of expertise will remain, probably in particularly enjoyable technology areas, while others usefully atrophy.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 37 · Location 547
</div>
<div class="noteText">
    This in turn leads to two common dysfunctions: first, an architect tries to maintain expertise in a wide variety of areas, succeeding in none of them and working themselves ragged in the process. Second, it manifests as stale expertise—the mistaken sensation that your outdated information is still cutting edge.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Technical Breadth > Page 38 · Location 553
</div>
<div class="noteText">
    Balancing their portfolio of knowledge regarding depth versus breadth is something every developer should consider throughout their career.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Analyzing Trade-Offs > Page 39 · Location 566
</div>
<div class="noteText">
    Thinking like an architect is all about seeing trade-offs in every solution, technical or otherwise, and analyzing those trade-offs to determine what is the best solution. To quote Mark (one of your authors): Architecture is the stuff you can’t Google.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Analyzing Trade-Offs > Page 39 · Location 570
</div>
<div class="noteText">
    Everything in architecture is a trade-off, which is why the famous answer to every architecture question in the universe is “it depends.” While many people get increasingly annoyed at this answer, it is unfortunately true. You cannot Google the answer to whether REST or messaging would be better, or whether microservices is the right architecture style, because it does depend.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Analyzing Trade-Offs > Page 39 · Location 572
</div>
<div class="noteText">
    It depends on the deployment environment, business drivers, company culture, budgets, timeframes, developer skill set, and dozens of other factors. Everyone’s environment, situation, and problem is different, hence why architecture is so hard.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Analyzing Trade-Offs > Page 39 · Location 575
</div>
<div class="noteText">
    There are no right or wrong answers in architecture—only trade-offs.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Analyzing Trade-Offs > Page 39 · Location 581
</div>
<div class="noteText">
    Architectural thinking requires the architect to analyze the trade-offs associated with each option and select the best one given the specific situation.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Analyzing Trade-Offs > Page 41 · Location 603
</div>
<div class="noteText">
    Programmers know the benefits of everything and the trade-offs of nothing. Architects need to understand both.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Analyzing Trade-Offs > Page 42 · Location 626
</div>
<div class="noteText">
    The point here is that everything in software architecture has a trade-off: an advantage and disadvantage.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Analyzing Trade-Offs > Page 42 · Location 628
</div>
<div class="noteText">
    The decision between different solutions will always depend on the business drivers, environment, and a host of other factors.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Understanding Business Drivers > Page 42 · Location 630
</div>
<div class="noteText">
    Thinking like an architect is understanding the business drivers that are required for the success of the system and translating those requirements into architecture characteristics (such as scalability, performance, and availability).
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Balancing Architecture and Hands-On Coding > Page 43 · Location 639
</div>
<div class="noteText">
    One of the difficult tasks an architect faces is how to balance hands-on coding with software architecture. We firmly believe that every architect should code and be able to maintain a certain level of technical depth (see “Technical Breadth”). While this may seem like an easy task, it is sometimes rather difficult to accomplish.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Balancing Architecture and Hands-On Coding > Page 43 · Location 644
</div>
<div class="noteText">
    The bottleneck trap occurs when the architect has taken ownership of code within the critical path of a project (usually the underlying framework code) and becomes a bottleneck to the team. This happens because the architect is not a full-time developer and therefore must balance between playing the developer role (writing and testing source code) and the architect role (drawing diagrams, attending meetings, and well, attending more meetings).
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Balancing Architecture and Hands-On Coding > Page 43 · Location 649
</div>
<div class="noteText">
    First, the architect is gaining hands-on experience writing production code while no longer becoming a bottleneck on the team. Second, the critical path and framework code is distributed to the development team (where it belongs), giving them ownership and a better understanding of the harder parts of the system. Third, and perhaps most important, the architect is writing the same business-related source code as the development team and is therefore better able to identify with the development team in terms of the pain they might be going through with processes, procedures, and the development environment.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Balancing Architecture and Hands-On Coding > Page 43 · Location 655
</div>
<div class="noteText">
    There are four basic ways an architect can still remain hands-on at work without having to “practice coding from home” (although we recommend practicing coding at home as well).
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Balancing Architecture and Hands-On Coding > Page 44 · Location 656
</div>
<div class="noteText">
    The first way is to do frequent proof-of-concepts or POCs. This practice not only requires the architect to write source code, but it also helps validate an architecture decision by taking the implementation details into account.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Balancing Architecture and Hands-On Coding > Page 44 · Location 666
</div>
<div class="noteText">
    Another way an architect can remain hands-on is to tackle some of the technical debt stories or architecture stories, freeing the development team up to work on the critical functional user stories.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Balancing Architecture and Hands-On Coding > Page 44 · Location 670
</div>
<div class="noteText">
    Similarly, working on bug fixes within an iteration is another way of maintaining hands-on coding while helping the development team as well.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Balancing Architecture and Hands-On Coding > Page 44 · Location 672
</div>
<div class="noteText">
    Leveraging automation by creating simple command-line tools and analyzers to help the development team with their day-to-day tasks is another great way to maintain hands-on coding skills while making the development team more effective.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Balancing Architecture and Hands-On Coding > Page 44 · Location 674
</div>
<div class="noteText">
    Look for repetitive tasks the development team performs and automate the process. The development team will be grateful for the automation.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Balancing Architecture and Hands-On Coding > Page 45 · Location 681
</div>
<div class="noteText">
    A final technique to remain hands-on as an architect is to do frequent code reviews. While the architect is not actually writing code, at least they are involved in the source code.
</div><div class="sectionHeading">
    3. Modularity
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Page 46 · Location 690
</div>
<div class="noteText">
    Different platforms offer different reuse mechanisms for code, but all support some way of grouping related code together into modules.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Page 46 · Location 698
</div>
<div class="noteText">
    architects must constantly expend energy to ensure good structural soundness, which won’t happen by accident.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Definition > Page 46 · Location 703
</div>
<div class="noteText">
    module as “each of a set of standardized parts or independent units that can be used to construct a more complex structure.”
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Definition > Page 46 · Location 704
</div>
<div class="noteText">
    use modularity to describe a logical grouping of related code, which could be a group of classes in an object-oriented language or functions in a structured or functional language.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Definition > Page 47 · Location 709
</div>
<div class="noteText">
    For example, in many modern languages, developers can define behavior in functions/ methods, classes, or packages/ namespaces, each with different visibility and scoping rules.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Definition > Page 47 · Location 712
</div>
<div class="noteText">
    Architects must be aware of how developers package things because it has important implications in architecture. For example, if several packages are tightly coupled together, reusing one of them for related work becomes more difficult.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Definition > Page 48 · Location 735
</div>
<div class="noteText">
    Most languages have some modularity mechanism that doubles as a namespace to organize things: variables, functions, and/ or methods. Sometimes the module structure is reflected physically. For example, Java requires that its package structure must reflect the directory structure of the physical class files.
</div><div class="noteHeading">
    Bookmark - Definition > Page 49 · Location 749
</div>
<div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Measuring Modularity > Page 49 · Location 755
</div>
<div class="noteText">
    We focus on three key concepts: cohesion, coupling, and connascence.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Cohesion > Page 49 · Location 757
</div>
<div class="noteText">
    Cohesion refers to what extent the parts of a module should be contained within the same module.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Cohesion > Page 49 · Location 760
</div>
<div class="noteText">
    Attempting to divide a cohesive module would only result in increased coupling and decreased readability. Larry Constantine
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Cohesion > Page 49 · Location 761
</div>
<div class="noteText">
    Computer scientists have defined a range of cohesion measures, listed here from best to worst: Functional cohesion Every part of the module is related to the other, and the module contains everything essential to function. Sequential cohesion Two modules interact, where one outputs data that becomes the input for the other. Communicational cohesion Two modules form a communication chain, where each operates on information and/ or contributes to some output. For example, add a record to the database and generate an email based on that information. Procedural cohesion Two modules must execute code in a particular order. Temporal cohesion Modules are related based on timing dependencies. For example, many systems have a list of seemingly unrelated things that must be initialized at system startup; these different tasks are temporally cohesive. Logical cohesion The data within modules is related logically but not functionally. For example, consider a module that converts information from text, serialized objects, or streams. Operations are related, but the functions are quite different. A common example of this type of cohesion exists in virtually every Java project in the form of the StringUtils package: a group of static methods that operate on String but are otherwise unrelated. Coincidental cohesion Elements in a module are not related other than being in the same source file; this represents the most negative form of cohesion.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Cohesion > Page 51 · Location 796
</div>
<div class="noteText">
    The Chidamber and Kemerer Lack of Cohesion in Methods (LCOM) metric measures the structural cohesion of a module, typically a component.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Cohesion > Page 52 · Location 808
</div>
<div class="noteText">
    LCOM The sum of sets of methods not shared via sharing fields
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Cohesion > Page 53 · Location 814
</div>
<div class="noteText">
    
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Cohesion > Page 53 · Location 815
</div>
<div class="noteText">
    In Figure 3-1, fields appear as single letters and methods appear as blocks. In Class X, the LCOM score is low, indicating good structural cohesion. Class Y, however, lacks cohesion; each of the field/ method pairs in Class Y could appear in its own class without affecting behavior. Class Z shows mixed cohesion, where developers could refactor the last field/ method combination into its own class.
</div><div class="noteHeading">
    Highlight(<span class="highlight_pink">pink</span>) - Coupling > Page 54 · Location 827
</div>
<div class="noteText">
    Afferent coupling measures the number of incoming connections to a code artifact (component, class, function, and so on). Efferent coupling measures the outgoing connections to other code artifacts.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Abstractness, Instability, and Distance from the Main Sequence > Page 54 · Location 840
</div>
<div class="noteText">
    Abstractness is the ratio of abstract artifacts (abstract classes, interfaces, and so on) to concrete artifacts (implementation). It represents a measure of abstractness versus implementation. For example, consider a code base with no abstractions, just a huge, single function of code (as in a single main() method). The flip side is a code base with too many abstractions, making it difficult for developers to understand how things wire together (for example, it takes developers a while to figure out what to do with an AbstractSingletonProxyFactoryBean).
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Abstractness, Instability, and Distance from the Main Sequence > Page 55 · Location 851
</div>
<div class="noteText">
    Another derived metric, instability, is defined as the ratio of efferent coupling to the sum of both efferent and afferent coupling,
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Abstractness, Instability, and Distance from the Main Sequence > Page 56 · Location 854
</div>
<div class="noteText">
    In the equation, ￼ represents efferent (or outgoing) coupling, and ￼ represents afferent (or incoming) coupling.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Abstractness, Instability, and Distance from the Main Sequence > Page 56 · Location 856
</div>
<div class="noteText">
    The instability metric determines the volatility of a code base. A code base that exhibits high degrees of instability breaks more easily when changed because of high coupling. For example, if a class calls to many other classes to delegate work, the calling class shows high susceptibility to breakage if one or more of the called methods change.
</div><div class="noteHeading">
    Highlight(<span class="highlight_yellow">yellow</span>) - Distance from the Main Sequence > Page 57 · Location 867
</div>
        </div>
    </body>
</html>